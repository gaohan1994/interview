## http 跨域以及解决方案

浏览器遵循同源策略，对于非同源的站点有限制
1、不能读取和修改对方 dom
2、不能读写对方 cookie、indexDB 以及 storage
3、不能发起 XMLHttpRequest

解决方案
1、JSONP
优点：兼容性强，缺点：只能 get 需要双端配合

2、cors
cors 是一个跨域资源共享标准，对简单请求和非简单请求处理方法不同

### 简单请求：

请求方法为 get 或者 post head 且请求类型是 application 的表单数据类型加一个 text/plain
对于简单请求，浏览器在请求头上会加上 Origin 表明请求源，服务器在收到请求之后会在响应头上加一个 Access-Control-Allow-Origin 字段
如果匹配通过则浏览器不拦截，如果不通过浏览器则拦截

### 非简单请求

1、发送预检请求
预检请求的格式为 options 报文内容是 origin + host 以及真实请求的请求方式

服务器接收到预检请求会设置允许跨域请求的源以及过期时间等头字段返回
浏览器接收到预检请求响应，进行判断如果通过则发送 cors 请求，不通过则直接执行报错逻辑

2、发送 cors 请求类似简单请求在执行一遍过程

## http2.0

是针对 http1.1 的一些问题发布的协议主要解决了 2 个大问题
1、头部压缩
2、队头阻塞

头部压缩主要方案是在双端建立和维护一张 hash 表，表的值是报文头的内容，这样双端在发送 http 请求的时候只要发送 hash 表的索引就行了

阻塞问题主要的方案是二进制分帧
之前是一问一答，前面的没应答后面的就阻塞了

为了改进，http2.0 把一个个报文拆分，拆分成一个个帧，帧包括了帧头、帧体
这样双端传输的时候传输的就是 很多帧组合成的 帧流

接受端在收到帧流的时候，根据帧中的帧类型判断是报文头还是报文体，在通过帧内的流 id 把不同报文的帧合并拼接成一个个完整的报文
这样就解决了阻塞问题

## https 是什么

https 相当于安全的 http 是 http 加上安全层 SSL

## https 的加密过程

略

## http 怎么实现大文件下载

利用 http 的 Accept-range 字段
手写一个分段下载功能

### 讲讲 http 缓存

https://www.jianshu.com/p/54cc04190252

缓存策略和位置

Memoery Cache 与 Disk Cache
即缓存在内存中和缓存在磁盘中
缓存在内存中速写速度最快，大小有限制

对于大文件来说，大概率是不存储在内存中的，反之优先
当前系统内存使用率高的话，文件优先存储进硬盘

用户行为对缓存的影响：

- 打开网页输入网址；查找缓存中是否匹配，如果匹配则直接使用缓存，如果没有则发送请求
- 刷新：没有关闭 tab 则优先检测 Memoery Cache 然后是 Disk Cache
- 强制刷新：不使用缓存，请求头中均携带 Cache-control: no-cache

1、强制缓存
由 expires 或者 cache-control 指定 cache-control 优先级更高
格式 expires：过期时间 | cache-control：max-age=36000
服务器返回的资源报文头上如果指定了这两个属性，则浏览器会把资源缓存起来
下次请求时会查看是否超过过期时间，如果没有的话直接使用缓存资源，如果超过过期时间发送请求并再次缓存

2、协商缓存
两种 Etag/ if-None-match 和 last-modify / if-modify-since
服务器拿到资源后对资源的响应报文头上可以设置 Etag 和 last-modify 字段
last-modify 可以设定资源上次修改的时间、如果服务器获取的响应报文中带有 last-modify 字段则缓存这个资源
下次再发送请求的时候带上 if-modify-since 服务器判断对比请求头的日期和资源上次修改的日期是否匹配
如果匹配则返回 304，这时候客户端会使用缓存资源，如果不匹配则返回新的资源并设置新的过期字段
Etag 流程差不多
